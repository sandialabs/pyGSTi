{% macro errorgenformula() %}
<span class="math">
    {% if errorgen_type == "logTiG" %}
    G = G_0 e^{\mathbb{L}}
    {% elif errorgen_type == "logGTi" %}
    G = e^{\mathbb{L}} G_0
    {% elif errorgen_type == "logG-logT" %}
    G = e^{\mathbb{L} + \log G_0}
    {% else %}
    ???
    {% endif %}
</span>
{% endmacro %}

<h1>Gate Error Generators</h1>
<p>This tab presents the <em>error generators</em> for each of the estimated gates.  Although these are not especially well-known in the literature, they are (in the pyGSTi authors' opinion) the most useful detailed diagnostic for gate errors.  The error generator <span class="math">\mathbb{L}</span> for a noisy gate <span class="math">G</span> with ideal target <span class="math">G_0</span> is defined by writing {{ errorgenformula() }}.  It can be thought of, more or less, as a Lindbladian superoperator that generates the error in the gate &mdash; with two caveats.  First, it is not necessarily of strict Lindblad form, because the GST-estimated gates may not be CP, and because even if they are, not every CP map is "divisible" (and nondivisible maps are not generated by Lindblad evolution).  Second, the generator reported here is a
    {% if errorgen_type == "logTiG" %}
    <em>pre-gate</em> generator, so it answers the question "If all the noise occurred <em>before</em> the ideal gate, what Lindbladian would generate it?"
    {% elif errorgen_type == "logGTi" %}
    <em>post-gate</em> generator, so it answers the question "If all the noise occurred <em>after</em> the ideal gate, what Lindbladian would generate it?"
    {% elif errorgen_type == "logG-logT" %}
    <em>during-gate</em> generator, so it answers the question "What Lindblad-type generate would produce this noise if it acted continuously <em>during</em> the gate?"  Note that this does <em>not necessarily</em> give insight into physics producing the noise.
    {% else %}
    ???
    {% endif %}
Finally:  the error generators are very definitely gauge-dependent, so <em>caveat emptor</em> (cross-validating any inferences drawn from these generators with some sort of gauge-invariant diagnostic is highly recommended).</p>

<figure id="bestGatesetErrGenTable" class='tbl'>
	<figcaption><span class="captiontitle">Logic gate error generators</span> <span class="captiondetail"> The <b>first column</b> displays a heat map of the estimated <q>error generator</q> for each gate.  This is (more or less) the Lindbladian <span class="math">\mathbb{L}</span> that describes <em>how</em> the gate is failing to match the target.  This error generator is defined by the equation {{ errorgenformula() }}. If it is zero, the estimated gate matches the corresponding ideal target gate.  Note that the range of the <span style="color:red">color</span> <span style="color:blue">scale</span> is dynamically adjusted. <b>Subsequent columns</b> show the result of projecting each generator onto some subspaces of the error generator space.  Each corresponds to a different classes of well-known errors:  Hamiltonian (coherent) errors, Pauli-stochastic errors, and affine (aka non-unital) errors.  The Hamiltonian generators act by commutation with each Pauli basis element <span class="math">B_i</span>, that is <span class="math">\rho \rightarrow -i[B_i, \rho]</span>.  Stochastic generators act by conjugation with each basis element, <span class="math">\rho \rightarrow B_i \rho B_i^\dagger</span>.  Affine generators act by projecting everything onto a particular basis element, <span class="math">\rho \rightarrow \mathrm{Tr}(\rho) B_i</span>.  Roughly speaking, the Hamiltonian projection corresponds precisely to the Hamiltonian that would produce the coherent part of the error, while the Pauli-stochastic generators correspond to the rates of all the Pauli errors (e.g., X errors, Z errors, their 2-qubit counterparts, or whatever is appropriate for the system being analyzed).</span></figcaption>
	{{ final_model_errorgen_box_table|render }}
</figure>
