"""
Defines the CHPForwardSimulator calculator class
"""
#***************************************************************************************************
# Copyright 2015, 2019 National Technology & Engineering Solutions of Sandia, LLC (NTESS).
# Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights
# in this software.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License.  You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0 or in the LICENSE file in the root pyGSTi directory.
#***************************************************************************************************
import os as _os
from pathlib import Path as _Path
import re as _re
import subprocess as _sp
import tempfile as _tf

from .label import Label as _Label
from .labeldicts import OutcomeLabelDict as _OutcomeLabelDict
from .profiler import DummyProfiler as _DummyProfiler
from .weakforwardsim import WeakForwardSimulator as _WeakForwardSimulator
from .verbosityprinter import VerbosityPrinter as _VerbosityPrinter
_dummy_profiler = _DummyProfiler()


class CHPForwardSimulator(_WeakForwardSimulator):
    """
    A WeakForwardSimulator returning probabilities with Scott Aaronson's CHP code
    """
    def __init__(self, chpexe, shots, model=None):
        """
        Construct a new CHPForwardSimulator.

        Parameters
        ----------
        chpexe: str or Path
            Path to CHP executable
        shots: int
            Number of times to run each circuit to obtain an approximate probability
        model : Model
            Optional parent Model to be stored with the Simulator
        """
        self.chpexe = _Path(chpexe)
        assert self.chpexe.is_file(), "A valid CHP executable must be passed to CHPForwardSimulator"

        super().__init__(shots, model)

    def _compute_circuit_outcome_for_shot(self, array_to_fill, spc_circuit, spc_outcomes, resource_alloc, time=None):
        """
        Compute probabilities of a multiple "outcomes" for a single circuit for a single shot.

        Parameters
        ----------

        spc_circuit : SeparatePOVMCircuit
            A tuple-like object of *simplified* gates (e.g. may include
            instrument elements like 'Imyinst_0') generated by
            Circuit.expand_instruments_and_separate_povm()
        
        spc_outcomes : tuple
            A tuple-like object of *simplified* effect labels generated by
            Circuit.expand_instruments_and_separate_povm()

        time : float, optional
            The *start* time at which `circuit` is evaluated.
        """
        assert(time is None), "CHPForwardSimulator cannot be used to simulate time-dependent circuits yet"

        circuit = spc_circuit.circuit_without_povm
        
        # Use temporary file as per https://stackoverflow.com/a/8577225
        fd, path = _tf.mkstemp()
        try:
            with _os.fdopen(fd, 'w') as tmp:
                tmp.write('#\n')

                # Prep (first operator is guaranteed to be )
                rho = self.model.circuit_layer_operator(circuit[0], 'prep')
                tmp.write(rho.get_chp_str())

                for op_label in circuit[1:-1]:
                    op = self.model.circuit_layer_operator(op_label, 'op')
                    tmp.write(op.get_chp_str())
                
                # POVM (sort of, actually using it more like a straight PVM)
                povm = self.model.circuit_layer_operator(spc_circuit.povm_label, 'povm')
                for i in range(povm.nqubits):
                    tmp.write(f'm {i}\n')

            # Run CHP
            process = _sp.Popen([f'{self.chpexe.resolve()}', f'{path}'], stdout=_sp.PIPE, stderr=_sp.PIPE)
            out, err = process.communicate()
        finally:
            _os.remove(path)

        # Extract outputs
        pattern = _re.compile('Outcome of measuring qubit (\d): (\d)')
        qubit_outcomes = []
        for match in pattern.finditer(out.decode('utf-8')):
            qubit_outcomes.append((int(match.group(1)), match.group(2)))

        # TODO: Make sure this handles intermediate measurements
        outcome = ''.join([qo[1] for qo in sorted(qubit_outcomes)])
        outcome_label = _OutcomeLabelDict.to_outcome(outcome)
        index = spc_outcomes.index(outcome_label)

        array_to_fill[index] += 1.0
